<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>bundleid</key>
	<string>com.surrealroad.alfred-reminder</string>
	<key>connections</key>
	<dict>
		<key>357C3151-39E1-42FD-8726-BBB740E0976C</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>A4F33D33-8B88-4725-993E-821A9D0CF057</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
		</array>
		<key>85F2415F-FAB1-457A-8FD6-AD14DEBFBC53</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>F71B4F2D-63BD-4B35-AA18-C6DDAA5A5CD9</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>9A786411-7C10-48D0-AD69-6E1E1DFB8F97</string>
				<key>modifiers</key>
				<integer>524288</integer>
				<key>modifiersubtext</key>
				<string>Show in Reminders.app</string>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>FD379784-5C4C-46D9-8D0A-36E768AF1321</string>
				<key>modifiers</key>
				<integer>262144</integer>
				<key>modifiersubtext</key>
				<string>Delete this reminder</string>
			</dict>
		</array>
		<key>8A923D62-221E-4666-96C6-82F3B6F92834</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>F71B4F2D-63BD-4B35-AA18-C6DDAA5A5CD9</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
		</array>
		<key>9A786411-7C10-48D0-AD69-6E1E1DFB8F97</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>159A291E-3339-491E-8D3F-79091BE0319B</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
		</array>
		<key>A4F33D33-8B88-4725-993E-821A9D0CF057</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>09C6CC9D-C9FE-4B32-BB4D-8E53F5D41AE8</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>94C011FF-2F31-415D-8811-A360D015D705</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
		</array>
		<key>A725F2F1-5A55-476A-9A26-E5B2BB71200E</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>F71B4F2D-63BD-4B35-AA18-C6DDAA5A5CD9</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>9A786411-7C10-48D0-AD69-6E1E1DFB8F97</string>
				<key>modifiers</key>
				<integer>524288</integer>
				<key>modifiersubtext</key>
				<string>Show in Reminders.app</string>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>FD379784-5C4C-46D9-8D0A-36E768AF1321</string>
				<key>modifiers</key>
				<integer>262144</integer>
				<key>modifiersubtext</key>
				<string>Delete this reminder</string>
			</dict>
		</array>
		<key>F71B4F2D-63BD-4B35-AA18-C6DDAA5A5CD9</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>159A291E-3339-491E-8D3F-79091BE0319B</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
		</array>
		<key>FD379784-5C4C-46D9-8D0A-36E768AF1321</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>159A291E-3339-491E-8D3F-79091BE0319B</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
			</dict>
		</array>
	</dict>
	<key>createdby</key>
	<string>Jack James</string>
	<key>description</key>
	<string>Manages reminders in Reminders.app</string>
	<key>disabled</key>
	<false/>
	<key>name</key>
	<string>Reminders</string>
	<key>objects</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>escaping</key>
				<integer>4</integer>
				<key>script</key>
				<string>property reminderList : ""property workflowFolder : do shell script "pwd"property lib: load script POSIX file (workflowFolder &amp; "/alfred_library.scpt")
property applib: load script POSIX file (workflowFolder &amp; "/reminder_apps.scpt")
property wf: load script POSIX file (workflowFolder &amp; "/q_workflow.scpt")
property bundleid : "com.surrealroad.alfred-reminder"property cacheFile : "cache.plist"

set wf to wf's new_workflow_with_bundle(bundleid)
set workflowFolder of lib to workflowFoldermy alfred_script("{query}")on alfred_script(q)
	if q is "@@UPDATE@@" then
		open location lib's getVersionURL(bundleid)
		return 
	end
	lib's setRemindersActive()	return lib's actionReminderQuery(q, false, applib, wf, cacheFile, reminderList)end alfred_script</string>
				<key>type</key>
				<integer>6</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>F71B4F2D-63BD-4B35-AA18-C6DDAA5A5CD9</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>lastpathcomponent</key>
				<false/>
				<key>onlyshowifquerypopulated</key>
				<true/>
				<key>output</key>
				<integer>0</integer>
				<key>removeextension</key>
				<false/>
				<key>sticky</key>
				<false/>
				<key>text</key>
				<string>{query}</string>
				<key>title</key>
				<string>Reminders</string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.notification</string>
			<key>uid</key>
			<string>159A291E-3339-491E-8D3F-79091BE0319B</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argumenttype</key>
				<integer>1</integer>
				<key>escaping</key>
				<integer>4</integer>
				<key>keyword</key>
				<string>r</string>
				<key>runningsubtext</key>
				<string>Processing request…</string>
				<key>script</key>
				<string>property cacheExpires : 2 * hours
property shouldCheckForUpdates : true
property checkFrequency : 4 * days
property showReminders : true

property currentVersion : 51
property workflowFolder : do shell script "pwd"property lib : load script POSIX file (workflowFolder &amp; "/alfred_library.scpt")
property wf : load script POSIX file (workflowFolder &amp; "/q_workflow.scpt")
property update : load script POSIX file (workflowFolder &amp; "/cache-update.scpt")
property wfname : "Reminders"
property bundleid : "com.surrealroad.alfred-reminder"property uid : "add-reminder"property addActionTitle : "Add Reminder"property cacheFile : "cache.plist"

set wf to wf's new_workflow_with_bundle(bundleid)
set workflowFolder of lib to workflowFolder
set osver to system version of (system info)
if (osver contains "10.9" or osver contains "10.10") then set showReminders to falsemy alfred_script("{query}")on alfred_script(q)	if q is "help" then return lib's alfred_result_items({lib's reminderHelp()})
	if q is "" and showReminders then set q to "all"	-- set create reminder action	set theText to ""	set valid to "no"	lib's setRemindersActive()	try		set reminder to lib's parseReminder(q)		set theText to theText of reminder		set theDate to theDate of reminder		set valid to valid of reminder		set theList to theList of reminder		set theApplication to theApplication of reminder		set theIcon to theIcon of reminder	end try		set subtitle to lib's formatReminderSubtitle(theText, theDate, theList, theApplication)		set addAction to ""	if ((theText is not "" and theText is not "all" and theText is not "refresh" and theText is not "overdue") or theApplication is not "") then		set addAction to lib's alfred_result_item_with_icon(uid, addActionTitle, subtitle, q, valid, theIcon)	end if		if theApplication is "" and showReminders then		if q is "refresh" then lib's spawnReminderCache(workflowFolder &amp; "/cache-reminders.scpt", false, "")		--fetch existing reminders		set reminderList to {}		set existingReminders to lib's fetchReminderList(wf, cacheFile, cacheExpires)		set filteredReminders to lib's filterReminders(existingReminders, theText, theDate, theList)	else		set filteredReminders to {}	end if		--version check	if shouldCheckForUpdates then		set cacheFile of update to cacheFile		set workflowFolder of update to (workflowFolder as string)		try			set versionAction to lib's alfred_version_notify(wfname, bundleid, currentVersion, wf, cacheFile, checkFrequency)		end try	else		set versionAction to ""	end if
	
	if ((addAction is "") and (filteredReminders is {})) then
		return lib's alfred_result_items({lib's alfred_result_item_with_icon("reminder-invalid", "Reminder command not recognised or no matching reminders found", "Type r help for some examples", "", "no", theIcon)})	end if		return lib's alfred_result_items({versionAction, addAction, filteredReminders})end alfred_script</string>
				<key>subtext</key>
				<string>Adds an entry to Reminders.app</string>
				<key>title</key>
				<string>Add Reminder</string>
				<key>type</key>
				<integer>6</integer>
				<key>withspace</key>
				<true/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>A725F2F1-5A55-476A-9A26-E5B2BB71200E</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>escaping</key>
				<integer>4</integer>
				<key>script</key>
				<string>property reminderList : ""property workflowFolder : do shell script "pwd"property lib: load script POSIX file (workflowFolder &amp; "/alfred_library.scpt")
property applib: load script POSIX file (workflowFolder &amp; "/reminder_apps.scpt")
property wf: load script POSIX file (workflowFolder &amp; "/q_workflow.scpt")
property bundleid : "com.surrealroad.alfred-reminder"property cacheFile : "cache.plist"

set wf to wf's new_workflow_with_bundle(bundleid)my alfred_script("{query}")

on alfred_script(q)	return lib's actionReminderQuery(q, true, applib, wf, cacheFile, reminderList)end alfred_script</string>
				<key>type</key>
				<integer>6</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>9A786411-7C10-48D0-AD69-6E1E1DFB8F97</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argumenttype</key>
				<integer>1</integer>
				<key>escaping</key>
				<integer>4</integer>
				<key>keyword</key>
				<string>radd</string>
				<key>runningsubtext</key>
				<string>Processing request…</string>
				<key>script</key>
				<string>property cacheExpires : 2 * hours

property workflowFolder : do shell script "pwd"property lib : load script POSIX file (workflowFolder &amp; "/alfred_library.scpt")
property wf : load script POSIX file (workflowFolder &amp; "/q_workflow.scpt")
property wfname : "Reminders"
property bundleid : "com.surrealroad.alfred-reminder"property uid : "add-reminder"property addActionTitle : "Add Reminder"property cacheFile : "cache.plist"

set wf to wf's new_workflow_with_bundle(bundleid)
set workflowFolder of lib to workflowFoldermy alfred_script("{query}")on alfred_script(q)	-- set create reminder action	set theText to ""	set valid to "no"	lib's setRemindersActive()	try		set reminder to lib's parseReminder(q)		set theText to theText of reminder		set theDate to theDate of reminder		set valid to valid of reminder		set theList to theList of reminder		set theApplication to theApplication of reminder		set theIcon to theIcon of reminder	end try		set subtitle to lib's formatReminderSubtitle(theText, theDate, theList, theApplication)		set addAction to ""	if ((theText is not "" and theText is not "all" and theText is not "refresh" and theText is not "overdue") or theApplication is not "") then		set addAction to lib's alfred_result_item_with_icon(uid, addActionTitle, subtitle, q, valid, theIcon)
	end if
	
	if addAction is "" then
		return lib's alfred_result_items({lib's alfred_result_item_with_icon("reminder-invalid", "Add reminder command not recognised", "Type r help for some examples", "", "no", theIcon)})	end if		return lib's alfred_result_items({addAction})end alfred_script</string>
				<key>subtext</key>
				<string>Adds an entry to Reminders.app</string>
				<key>title</key>
				<string>Add Reminder</string>
				<key>type</key>
				<integer>6</integer>
				<key>withspace</key>
				<true/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>8A923D62-221E-4666-96C6-82F3B6F92834</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argumenttype</key>
				<integer>1</integer>
				<key>escaping</key>
				<integer>4</integer>
				<key>keyword</key>
				<string>rshow</string>
				<key>runningsubtext</key>
				<string>Fetching reminders…</string>
				<key>script</key>
				<string>property cacheExpires : 2 * hoursproperty workflowFolder : do shell script "pwd"property lib : load script POSIX file (workflowFolder &amp; "/alfred_library.scpt")property wf : load script POSIX file (workflowFolder &amp; "/q_workflow.scpt")property wfname : "Reminders"property bundleid : "com.surrealroad.alfred-reminder"property cacheFile : "cache.plist"
property showReminders : trueset wf to wf's new_workflow_with_bundle(bundleid)set workflowFolder of lib to workflowFolder
set osver to system version of (system info)
if (osver contains "10.9" or osver contains "10.10") then set showReminders to falseif showReminders then my alfred_script("{query}")on alfred_script(q)
	set theText to ""	set valid to "no"	lib's setRemindersActive()
	try		set reminder to lib's parseReminder(q)		set theText to theText of reminder		set theDate to theDate of reminder		set valid to valid of reminder		set theList to theList of reminder		set theIcon to theIcon of reminder	end try		--fetch existing reminders	set reminderList to {}	set existingReminders to lib's fetchReminderList(wf, cacheFile, cacheExpires)	set filteredReminders to lib's filterReminders(existingReminders, theText, theDate, theList)	
	if filteredReminders is {} then
		return lib's alfred_result_items({lib's alfred_result_item_with_icon("reminder-invalid", "No matching reminders found", "Please try a different query", "", "no", theIcon)})	end if		return lib's alfred_result_items({filteredReminders})end alfred_script</string>
				<key>subtext</key>
				<string>Show current reminders</string>
				<key>title</key>
				<string>Show Reminders</string>
				<key>type</key>
				<integer>6</integer>
				<key>withspace</key>
				<true/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>85F2415F-FAB1-457A-8FD6-AD14DEBFBC53</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>escaping</key>
				<integer>4</integer>
				<key>script</key>
				<string>property reminderList : ""property workflowFolder : do shell script "pwd"property lib: load script POSIX file (workflowFolder &amp; "/alfred_library.scpt")
property applib: load script POSIX file (workflowFolder &amp; "/reminder_apps.scpt")
property wf: load script POSIX file (workflowFolder &amp; "/q_workflow.scpt")
property bundleid : "com.surrealroad.alfred-reminder"property cacheFile : "cache.plist"

set wf to wf's new_workflow_with_bundle(bundleid)my alfred_script("{query}")

on alfred_script(q)	return lib's actionReminderQuery("##DEL##" &amp; q, false, applib, wf, cacheFile, reminderList)end alfred_script</string>
				<key>type</key>
				<integer>6</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>FD379784-5C4C-46D9-8D0A-36E768AF1321</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>lastpathcomponent</key>
				<false/>
				<key>onlyshowifquerypopulated</key>
				<false/>
				<key>output</key>
				<integer>0</integer>
				<key>removeextension</key>
				<false/>
				<key>sticky</key>
				<false/>
				<key>text</key>
				<string>Results have been copied to the clipboard</string>
				<key>title</key>
				<string>Test complete</string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.notification</string>
			<key>uid</key>
			<string>09C6CC9D-C9FE-4B32-BB4D-8E53F5D41AE8</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>escaping</key>
				<integer>4</integer>
				<key>script</key>
				<string>property cacheExpires : 2 * hoursproperty workflowFolder : missing valueproperty lib : missing valueproperty wf : missing valueproperty update : missing valueproperty cacheFile : "cache.plist"property bundleid : "com.surrealroad.alfred-reminder"property wfname : "Reminders"set theResult to ""set startTime to (current date)-- OS versionset theResult to theResult &amp; "OS version: "
set testStart to (current date)try	set os_version to do shell script "sw_vers -productVersion"	set theResult to theResult &amp; os_versionon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- timestampset theResult to theResult &amp; "Current date: "
set testStart to (current date)try	set theResult to theResult &amp; (current date)on error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend tryset theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- initialise librariesset theResult to theResult &amp; "Initialize workflow path: "
set testStart to (current date)try	set workflowFolder to do shell script "pwd"	set theResult to theResult &amp; workflowFolderon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Initialize alfred-library: "set testStart to (current date)try	set lib to load script POSIX file (workflowFolder &amp; "/alfred_library.scpt")	if lib is not missing value then		set workflowFolder of lib to workflowFolder		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return

set theResult to theResult &amp; "Initialize update-library: "
set testStart to (current date)try	set update to load script POSIX file (workflowFolder &amp; "/cache-update.scpt")	if update is not missing value then		set cacheFile of update to cacheFile		set workflowFolder of update to workflowFolder		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Initialize wf-library: "
set testStart to (current date)try	set wf to load script POSIX file (workflowFolder &amp; "/q_workflow.scpt")	set wf to wf's new_workflow_with_bundle(bundleid)	if wf is not missing value then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return

set theResult to theResult &amp; "Initialize plist-library: "
set testStart to (current date)try	set _plist to load script POSIX file (workflowFolder &amp; "/_plist.scpt")	if _plist is not missing value then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- test determining reminders stateset theResult to theResult &amp; "Reminders.app state: "
set testStart to (current date)try	tell application "System Events"		set remindersIsRunning to (bundle identifier of processes) contains "com.apple.reminders"	end tell	if remindersIsRunning then		set theResult to theResult &amp; "Running"	else		set theResult to theResult &amp; "Not running"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- test reading data from remindersset theResult to theResult &amp; "Fetch reminder count: "
set testStart to (current date)try	tell application id "com.apple.reminders"		set reminderList to reminders whose (completed is false)	end tell	set theResult to theResult &amp; (count of reminderList)on error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Fetch reminder info: "
set testStart to (current date)try	set reminderText to missing value	tell application id "com.apple.reminders"		set reminderText to name of first reminder whose (completed is false)	end tell	if reminderText is not missing value then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Fetch reminder list count: "set testStart to (current date)try	tell application id "com.apple.reminders"		set reminderListList to lists	end tell	set theResult to theResult &amp; (count of reminderListList)on error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; returnset theResult to theResult &amp; "Fetch reminder list info: "
set testStart to (current date)try	set reminderList to missing value	tell application id "com.apple.reminders"		set reminderList to name of first list	end tell	if reminderList is not missing value then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- test fetching cached variablesset theResult to theResult &amp; "Run cache process: "
set testStart to (current date)try	set cacheResult to do shell script "osascript " &amp; quoted form of workflowFolder &amp; "/cache-reminders.scpt"	if cacheResult is "" then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; cacheResult	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Fetch cache timestamp: "
set testStart to (current date)try	set theResult to theResult &amp; wf's get_value("timestamp", cacheFile)on error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Fetch cached reminder count: "
set testStart to (current date)try	set cachedReminderList to lib's getCachedReminderList(wf, cacheFile)	set theResult to theResult &amp; (count of cachedReminderList)on error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- test parseReminder suiteset theResult to theResult &amp; "Test basic query: "
set testStart to (current date)try	set q to "something"	set qResult to lib's parseReminder(q)	if (theText of qResult) is equal to q then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test today query: "
set testStart to (current date)try	set q to "today"	set qResult to lib's parseReminder(q)	if date string of (theDate of qResult) is equal to date string of (current date) then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test in n minutes query: "
set testStart to (current date)try	set q to "in 5 minutes something"	set qResult to lib's parseReminder(q)	if (theDate of qResult) is equal to ((current date) + 5 * minutes) then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test in n hours query: "
set testStart to (current date)try	set q to "in 5 hours something"	set qResult to lib's parseReminder(q)	if (theDate of qResult) is equal to ((current date) + 5 * hours) then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test in n days query: "
set testStart to (current date)try	set q to "in 5 days something"	set qResult to lib's parseReminder(q)	if (theDate of qResult) is equal to ((current date) + 5 * days) then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test in n days y hours query: "
set testStart to (current date)try	set q to "in 5 days 1 hour something"	set qResult to lib's parseReminder(q)	if (theDate of qResult) is equal to ((current date) + (5 * days) + hours) then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test in n hours y minutes query: "
set testStart to (current date)try	set q to "in 5 hours 6 minutes something"	set qResult to lib's parseReminder(q)	if (theDate of qResult) is equal to ((current date) + (5 * hours) + (6 * minutes)) then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test at time query: "
set testStart to (current date)try	set q to "at 2pm to something"	set qResult to lib's parseReminder(q)	set theTime to (current date)	set theTime's time to 14 * hours	if (time of (theDate of qResult)) is equal to (time of (theTime)) then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test tomorrow at time query: "
set testStart to (current date)try	set q to "tomorrow at 11am to something"	set qResult to lib's parseReminder(q)	set theTime to (current date)	set theTime's time to 11 * hours	if date string of (theDate of qResult) is equal to date string of ((current date) + 24 * hours) ¬		and (time of (theDate of qResult)) is equal to (time of (theTime)) then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test in x list query: "
set testStart to (current date)try	set q to "in something in test result list"	set qResult to lib's parseReminder(q)	if (theList of qResult) is equal to "test result" then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- test subtitle generationset theResult to theResult &amp; "Subtitle generation: "
set testStart to (current date)try	set theText to "test"	set theDate to current date	set theList to "test list"	set theApplication to ""	set expectedResult to "Create a new reminder to test on " &amp; (theDate as string) &amp; " in " &amp; quoted form of theList	set qResult to lib's formatReminderSubtitle(theText, theDate, theList, theApplication)	if qResult is equal to expectedResult then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- test reminder filteringset theResult to theResult &amp; "Test basic reminder filtering: "
set testStart to (current date)try	set theUID to "test"	set theText to "something"	set theDate to ""	set theList to ""	set theReminder to {uid:theUID, title:theText, creationdate:(current date)}	set reminderList to {theReminder}	set infoText to (" (started on " &amp; (current date) as string) &amp; ")"	set expectedResult to lib's alfred_result_item_with_icon(theUID, theText, ¬		"Set as complete" &amp; infoText, "uid:" &amp; theUID, "yes", "checked.png")	set filteredReminders to lib's filterReminders(reminderList, theText, theDate, theList)	if first item of filteredReminders is equal to expectedResult then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test remind today reminder filtering: "
set testStart to (current date)try	set theUID to "test"	set theText to "something"	set theDate to (current date)	set theList to ""	set theReminder to {uid:theUID, title:theText, creationdate:(current date), reminddate:theDate}	set reminderList to {theReminder}	set infoText to (" (started on " &amp; (current date) as string) &amp; ")"	set expectedResult to lib's alfred_result_item_with_icon(theUID, theText, ¬		"Set as complete" &amp; infoText, "uid:" &amp; theUID, "yes", "checked.png")	set filteredReminders to lib's filterReminders(reminderList, theText, theDate, theList)	if first item of filteredReminders is equal to expectedResult then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test due tomorrow reminder filtering: "
set testStart to (current date)try	set theUID to "test"	set theText to "something"	set theDate to (current date) + 24 * hours	set theList to ""	set theReminder to {uid:theUID, title:theText, creationdate:(current date), duedate:theDate}	set reminderList to {theReminder}	set infoText to ((" (due on " &amp; theDate as string) &amp; ", started on " &amp; (current date) as string) &amp; ")"	set expectedResult to lib's alfred_result_item_with_icon(theUID, theText, ¬		"Set as complete" &amp; infoText, "uid:" &amp; theUID, "yes", "checked.png")	set filteredReminders to lib's filterReminders(reminderList, theText, theDate, theList)	if first item of filteredReminders is equal to expectedResult then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail" &amp; return				set theResult to theResult &amp; first item of filteredReminders &amp; return		set theResult to theResult &amp; expectedResult	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Test reminder list filtering: "
set testStart to (current date)try	set theUID to "test"	set theText to "something"	set theDate to ""	set theList to "test list"	set theReminder to {uid:theUID, title:theText, creationdate:(current date), parentlist:theList}	set reminderList to {theReminder}	set infoText to (" (started on " &amp; (current date) as string) &amp; ")"	set expectedResult to lib's alfred_result_item_with_icon(theUID, theText, ¬		"Set as complete" &amp; infoText, "uid:" &amp; theUID, "yes", "checked.png")	set filteredReminders to lib's filterReminders(reminderList, theText, theDate, theList)	if first item of filteredReminders is equal to expectedResult then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- test application-- test update checkingset theResult to theResult &amp; "Test version-check response: "
set testStart to (current date)try	set verCheck to lib's alfred_version_notify(wfname, bundleid, 0, wf, cacheFile, 0)	if verCheck is not "" then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return-- test miscellaneous functionsset theResult to theResult &amp; "Current unix time: "
set testStart to (current date)try	set theResult to theResult &amp; lib's unixtime(current date)on error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return
set theResult to theResult &amp; "Simple JSON: "
set testStart to (current date)try	set expectedResult to {"version", "2"}	if lib's splitByColon("version:  2") is equal to expectedResult then		set theResult to theResult &amp; "OK"	else		set theResult to theResult &amp; "Fail"	end ifon error errMsg	set theResult to theResult &amp; "ERROR: " &amp; errMsgend try
set theResult to theResult &amp; " (" &amp; ((current date) - testStart) &amp; " seconds)" &amp; return--stop timerset theResult to theResult &amp; "Test execution time: "set theResult to theResult &amp; ((current date) - startTime) &amp; " seconds" &amp; returnreturn theResult</string>
				<key>type</key>
				<integer>6</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>A4F33D33-8B88-4725-993E-821A9D0CF057</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>argumenttype</key>
				<integer>2</integer>
				<key>keyword</key>
				<string>rtest</string>
				<key>subtext</key>
				<string>Run a series of tests and put the results on the clipboard</string>
				<key>text</key>
				<string>Test Reminders Workflow</string>
				<key>withspace</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.keyword</string>
			<key>uid</key>
			<string>357C3151-39E1-42FD-8726-BBB740E0976C</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>autopaste</key>
				<false/>
				<key>clipboardtext</key>
				<string>Test results:
{query}</string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.clipboard</string>
			<key>uid</key>
			<string>94C011FF-2F31-415D-8811-A360D015D705</string>
			<key>version</key>
			<integer>0</integer>
		</dict>
	</array>
	<key>readme</key>
	<string>This creates a new reminder in reminders.app
 
To use, just type "r reminder_text" into Alfred. E.g. "r check out some of Alfred's other workflows" to find an existing reminder with the search text, or to create a new one.
Actioning an existing reminder marks it as complete.
Hold option to view the new/existing reminder in Reminders.app, hold control to delete it.

To set a reminder for a specific date, use any of the following commands:
r today release the hamsters into the wild
r tomorrow bring about financial ruin upon my enemies
r in 5 minutes drop everything
r in 2 hours laugh out loud in random thoughts list
r in 3 days 1 hour pick stuff up off the floor
r on 24/12/13 to forget everything I know about things in movies
r on 12 June 15 to come up with some interesting ideas
r on 11 12 13 to check what the weather's like
r on 31-12-99 23:22 to panic about the millennium bug
r at 2pm to wait for nothing in particular
r thursday at 15.30 to ask some difficult questions

"r all" will show all current reminders
"r refresh" will show all current reminders and refresh the list

"r this" will capture the current application and turn it into a reminder

All sorts of combinations are possible!

"r help" will display the above examples

"r overdue" will display reminders which are overdue

The order of d/m/y (as well as HH:mm) I believe will depend on your region settings in the OS.
 
If you want to change the default reminder list, edit the applescript property at the top, otherwise it will just use the first one (unless you use "in Y list" at the end).
 
Changelog:

Saturday, 26 July 2014 – Disable showing reminders in OS 10.10 (Yosemite)
Thursday, 9 January 2014 – Fixed Finder links in OS 10.9
Saturday, 23 November 2013 – Disable display of existing reminders under OS 10.9
Friday, 22 November 2013 – Workflow will now display a message if the command is not valid
Saturday, 2 November 2013 – Fixed an issue that would cause the workflow to crash the first few times it was run; fixed an issue that would prevent update checking to work correctly
Friday, 1 November 2013 – Fixed an issue where caching reminders would cause update checking to fail
Wednesday, 23 October 2013 – Increased timeout on OS 10.9, and allowed reminders to be retrieved from the cache while it's running; times specified without am/pm are now assumed to be in 24hour format; corrected an issue where 12 o'clock times were calculated incorrectly; you can now use "noon" and "midnight" to specify time
Tuesday, 22 October 2013 – Prevent cache processes overlapping; recreate damaged cache file if needed; workaround for OS 10.9 GM2 plist bug
Wednesday, 9 October 2013 – Added support for Google Chrome Canary; added plain text formats of applescripts; fix for cache process failing for new users
Monday, 7 October 2013 – Added profiling to rtest, "r" with no arguments is now the same as "r all"
Friday, 4 October 2013 – Compatibility with OS 10.9 Mavericks GM
Wednesday, 18 September 2013 – Fix for non-gregorian date format
Tuesday, 17 September 2013 – Updated q_workflow module to latest version
Thursday, 18 April 2013 – Fixed recognition of 10/11/12am/pm times
Tuesday, 16 April 2013 – Added support for WebKit nightly builds
Monday, 15 April 2013 – Added "r in x days y hours", "r in x hours y minutes", "r today/tomorrow/weekday at time to x" patterns
Thursday, 11 April 2013 – Added support for OmniFocus, Vienna, reminder from address book now adds a link to the contact
Wednesday, 10 April 2013 – Fix for -609 error (thanks, stevef!)
Tuesday, 9 April 2013 – Added "r refresh" keyword to refresh list ("r all" will no longer refresh the list); added "rshow", which will only show options for existing reminders, "radd", which will only show options for adding new reminders; added "rtest" which runs a set of tests to check for potential problems; fixed an issue that would cause workflow to crash (thanks, erist!)
Monday, 8 April 2013 – Better compatibility for editing library scripts on other systems; it's now possible to delete reminders by holding down control; fixed a rare issue where the workflow might incorrectly report a new version is available; iconography tweak; added "r overdue"; added support for TextMate and TextEdit; allow "r in 1 minute/hour/day"
Sunday, 7 April 2013 – Don't mark reminder as complete with option held down; properly escape illegal characters in query; added support for Finder and Chromium
Saturday, 6 April 2013 – Added "r this" which captures data from the current application and turns it into a reminder; support for Google Chrome, Safari, and Mail; fixed a regression; support for contacts/address book; added icons from the icon factory; "r all" now refreshes the cache
Friday, 5 April 2013 – Show "r all" in help; don't close reminders if its been moved to the foreground; all keywords can now be used to filter displayed reminders; changed the cache duration to 2 hours; subtitle for existing reminders shows more information where possible
Thursday, 4 April 2013 – Performance improvements; hold option to view the selected reminder in Reminders.app
Wednesday, 3 April 2013 – Fix for "in list" pattern breaking up text; added "r help" examples; don't prompt to create reminder with "all" keyword; checks for newer versions of the workflow
Tuesday, 2 April 2013 – If reminders.app is closed, it will stay closed when using this workflow
Sunday, 31 March 2013 – Added pattern "r Wednesday something"
Wednesday, 27 March 2013 – Renamed workflow to "Reminders"; Use application id instead of name, Alfred now shows existing reminders in his list (selecting one will mark it as complete); keyword is now optional
Tuesday, 26 March 2013 – Now sets specified date as the reminder date, rather than due date; added pattern "r something in Y list"
Wednesday, 20 March 2013 – You can now use the pattern "r at 1.30 to something"; Alfred will tell you what's going to happen before you press enter; split off code to library file
Tuesday, 19 March 2013 – You can now use the pattern "r in X minutes/hours/days something"
Sunday, 17 March 2013 – You can now specify a date for the reminder. See the examples above.

Uses AppleScript implementation of the Workflow object class for Alfred 2 (https://github.com/qlassiqa/qWorkflow)
Uses icons from the Flurry collection by David Lanham / The Icon Factory
Uses Brati's Lover Property List Library (http://applescript.bratis-lover.net/library/plist/)</string>
	<key>uidata</key>
	<dict>
		<key>09C6CC9D-C9FE-4B32-BB4D-8E53F5D41AE8</key>
		<dict>
			<key>ypos</key>
			<real>350</real>
		</dict>
		<key>159A291E-3339-491E-8D3F-79091BE0319B</key>
		<dict>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>357C3151-39E1-42FD-8726-BBB740E0976C</key>
		<dict>
			<key>ypos</key>
			<real>410</real>
		</dict>
		<key>85F2415F-FAB1-457A-8FD6-AD14DEBFBC53</key>
		<dict>
			<key>ypos</key>
			<real>290</real>
		</dict>
		<key>8A923D62-221E-4666-96C6-82F3B6F92834</key>
		<dict>
			<key>ypos</key>
			<real>170</real>
		</dict>
		<key>94C011FF-2F31-415D-8811-A360D015D705</key>
		<dict>
			<key>ypos</key>
			<real>470</real>
		</dict>
		<key>9A786411-7C10-48D0-AD69-6E1E1DFB8F97</key>
		<dict>
			<key>ypos</key>
			<real>170</real>
		</dict>
		<key>A4F33D33-8B88-4725-993E-821A9D0CF057</key>
		<dict>
			<key>ypos</key>
			<real>410</real>
		</dict>
		<key>A725F2F1-5A55-476A-9A26-E5B2BB71200E</key>
		<dict>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>F71B4F2D-63BD-4B35-AA18-C6DDAA5A5CD9</key>
		<dict>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>FD379784-5C4C-46D9-8D0A-36E768AF1321</key>
		<dict>
			<key>ypos</key>
			<real>290</real>
		</dict>
	</dict>
	<key>webaddress</key>
	<string>http://www.surrealroad.com</string>
</dict>
</plist>
